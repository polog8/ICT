<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Content Tool</title>
    <link rel="icon" href="https://raw.githubusercontent.com/polog8/ICT/main/Lien_Mapping_Icon.svg" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #10b981;
            --danger: #ef4444;
            --dark: #111827;
            --light: #f9fafb;
            --gray: #6b7280;
            --gray-light: #e5e7eb;
            --radius: 8px;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section {
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 30px;
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title svg {
            width: 24px;
            height: 24px;
        }

        .section-description {
            color: var(--gray);
            margin-bottom: 20px;
            font-size: 15px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .input-group.full {
            width: 100%;
        }

        input, select, textarea, button {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            border-radius: var(--radius);
            transition: all 0.2s ease;
        }

        input, select, textarea {
            border: 1px solid var(--gray-light);
            padding: 10px 14px;
            flex-grow: 1;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 16px;
            cursor: pointer;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        button:hover {
            background-color: var(--primary-dark);
        }
        
        button:disabled {
            background-color: var(--gray-light);
            cursor: not-allowed;
        }

        button svg {
            width: 16px;
            height: 16px;
        }

        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            background-color: #0d9668;
        }

        .btn-danger {
            background-color: var(--danger);
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .btn-outline {
            background-color: transparent;
            color: var(--dark);
            border: 1px solid var(--gray-light);
        }

        .btn-outline:hover {
            background-color: var(--gray-light);
        }

        .output-display {
            background-color: #f8fafc;
            border-radius: var(--radius);
            padding: 16px;
            margin-top: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .output-display p {
            margin: 0;
            word-break: break-all;
            color: var(--primary);
            font-weight: 500;
        }

        #canvasContainer {
            position: relative;
            display: inline-block;
            margin-top: 16px;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        canvas {
            display: block;
            cursor: crosshair;
        }

        canvas.draggable {
            cursor: grab;
        }
        canvas.dragging {
            cursor: grabbing;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: var(--radius);
            overflow: hidden;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--gray-light);
            vertical-align: middle;
        }

        th {
            background-color: #f8fafc;
            font-weight: 500;
            color: var(--dark);
        }

        td {
            font-size: 14px;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
        }

        .editor-panel {
            background-color: #f8fafc;
            border-radius: var(--radius);
            padding: 20px;
            margin-top: 20px;
        }

        .editor-fields {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .editor-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 16px;
        }

        textarea {
            width: 100%;
            min-height: 100px;
            font-family: monospace;
            resize: vertical;
            background-color: #f8fafc;
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 8px;
        }

        .tooltip .tooltip-text {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }

        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }

            .section {
                padding: 20px;
            }

            .editor-fields {
                grid-template-columns: 1fr;
            }
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background-color: var(--light);
            border: 1px solid var(--gray-light);
            border-radius: var(--radius);
            margin-bottom: 8px;
            transition: background-color 0.2s ease;
        }

        .config-item:hover {
            background-color: var(--gray-light);
        }

        .config-item a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 500;
        }

        .config-item a:hover {
            text-decoration: underline;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: var(--shadow);
            z-index: 1;
            border-radius: var(--radius);
        }

        .dropdown-content a {
            color: var(--dark);
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:hover {
            background-color: var(--gray-light);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: rgb(255, 255, 255);
            border-radius: var(--radius);
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            overflow-y: auto;
            padding: 30px;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--gray-light);
        }

        .modal-title {
            font-size: 22px;
            font-weight: 600;
        }

        .modal-close-btn {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: var(--gray);
            padding: 0;
        }

        .guide-content h1, .guide-content h2, .guide-content h3 {
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            color: var(--dark);
        }
        .guide-content p {
            margin-bottom: 1em;
            line-height: 1.7;
        }
        .guide-content code {
            background-color: var(--gray-light);
            padding: 2px 5px;
            border-radius: 4px;
            font-family: monospace;
        }
        .guide-content pre {
            background-color: var(--dark);
            color: #fffffe;
            padding: 1em;
            border-radius: var(--radius);
            overflow-x: auto;
            margin-bottom: 1em;
        }
        .guide-content ul {
            margin-bottom: 1em;
            padding-left: 20px;
        }
        .guide-content a {
            color: var(--primary);
            text-decoration: none;
        }
        .guide-content a:hover {
            text-decoration: underline;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 70px;
            padding: 0 40px;
            background-color: rgb(226, 226, 226);
            box-shadow: 0 2px 4px rgba(0,0,0,0.25);
            z-index: 1000;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .control-panel button.active {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        .control-panel button.active svg {
            stroke: white;
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div class="header-brand">
            <img src="https://raw.githubusercontent.com/polog8/ICT/main/Lien_Mapping_Icon.svg" style="height: 50px;" alt="Logo de l'application ICT">
            <h1 class="header-title">Interactive Content Tool</h1>
        </div>
        <button id="userGuideBtn" class="btn-outline" style="background-color: #ffffff; border-color: #333;">
            Guide Utilisateur
        </button>
    </header>

    <div style="height: 80px;"></div>

    <div id="guideModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Guide Utilisateur</h2>
                <button class="modal-close-btn" onclick="closeGuide()">×</button>
            </div>
            <div id="guideContent" class="guide-content">
                <p>Chargement du guide...</p>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
            </svg>
            Convertisseur de lien Google Drive
        </h2>
        <p class="section-description">Transformez vos liens Google Drive en liens d'image directe pour une meilleure intégration.</p>
        <div class="input-group full">
            <input type="text" id="inputLink" placeholder="Collez votre lien Google Drive ici" spellcheck="false">
            <button onclick="convertLink()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>
                </svg>
                Convertir
            </button>
        </div>
        <div id="output" class="output-display" style="display: none;"></div>
        <div id="embedOutput" class="output-display" style="display: none;"></div>
    </div>


    <div class="section">
        <h2 class="section-title">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
            Mapper d'Images Interactif
        </h2>
        <p class="section-description">Pour créer une zone : cliquez et faites glisser sur l'image. Pour sélectionner une zone existante : cliquez dessus.</p>
        <div class="input-group full">
            <input type="text" id="imageURL" placeholder="Entrez l'URL de l'image à mapper (provenant du convertisseur ci-dessus)" spellcheck="false">
            <button onclick="loadImage()">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
                </svg>
                Charger l'image
            </button>
        </div>
        <div class="control-panel">
            <button onclick="resetZones()" class="btn-outline">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M2 12A10 10 0 1 0 12 2a10 10 0 0 0-10 10z"></path>
                    <path d="M12 6v6l4 2"></path>
                </svg>
                Réinitialiser
            </button>
            <button onclick="saveZones()" class="btn-outline">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                    <polyline points="17 21 17 13 7 13 7 21"></polyline>
                    <polyline points="7 3 7 8 15 8"></polyline>
                </svg>
                Sauvegarder
            </button>
            <button onclick="loadZones()" class="btn-outline">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
                Charger
            </button>
            <div class="checkbox-container">
                <input type="checkbox" id="snapToggle" onchange="toggleSnap()">
                <label for="snapToggle">Snap sur grille</label>
                <div class="tooltip">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>
                    </svg>
                    <span class="tooltip-text">Aligne automatiquement les zones sur une grille de 5px pour plus de précision</span>
                </div>
            </div>
        </div>
        <div class="control-panel" style="border-top: 1px solid var(--gray-light); padding-top: 20px; margin-top: 0;">
            <label style="font-weight: 500;">Outil de dessin :</label>
            <button id="shape-rect" class="btn-outline active">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                Rectangle
            </button>
            <button id="shape-circle" class="btn-outline">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle></svg>
                Cercle
            </button>
            <button id="shape-poly" class="btn-outline">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l10 6.5v7L12 22 2 15.5v-7L12 2z"></path></svg>
                Polygone
            </button>
        </div>

        <div id="canvasContainer">
            <canvas id="imageCanvas"></canvas>
        </div>

        <div id="zoneEditor" class="editor-panel" style="display:none;">
            <h3 style="margin-bottom: 16px; font-size: 18px;">Éditer la zone sélectionnée</h3>
            <div class="editor-fields">
                <input type="text" id="editTitle" placeholder="Titre (tooltip)">
                <input type="text" id="editLink" placeholder="URL du lien">
                <select id="editTarget">
                    <option value="_top">Pleine fenêtre (_top) (No Link)</option>
                    <option value="_blank">Nouvelle fenêtre (_blank) (Link)</option>
                    <option value="_self">Même fenêtre (_self)</option>
                    <option value="_parent">Fenêtre parente (_parent)</option>
                </select>
                <div style="display: flex; align-items: center;">
                    <label style="margin-right: 10px;">Couleur :</label>
                    <input type="color" id="editColor" value="#ff0000" style="width: 40px; height: 40px; padding: 0;">
                </div>
            </div>
            <div class="editor-actions">
                <button class="btn-outline" onclick="cancelEdit()">Annuler</button>
                <button onclick="updateZone()">Enregistrer</button>
            </div>
        </div>

        <div id="areasList" style="margin-top: 20px;">
            <h3 style="margin-bottom: 16px; font-size: 18px;">Liste des zones</h3>
            <table id="areasTable">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Ordre</th> <th>Forme</th>
                        <th>Coordonnées</th>
                        <th>Titre</th>
                        <th>Lien</th>
                        <th>Cible</th>
                        <th>Couleur</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>

        <div style="margin-top: 30px;">
            <h3 style="margin-bottom: 16px; font-size: 18px;">Code HTML généré</h3>
            <textarea id="htmlOutput" rows="10" readonly spellcheck="false"></textarea>
            <div style="margin-top: 10px; text-align: right;">
                <button id="copyHtmlButton" onclick="copyHtmlCode()" class="btn-secondary">Copier le code</button>
            </div>
        </div>

        <div id="savedConfigsList" class="section-description" style="margin-top: 20px;">
            <h3 style="font-size: 18px;">Configurations sauvegardées</h3>
            <ul id="configsList" style="list-style: none; padding: 0;"></ul>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const guideBtn = document.getElementById('userGuideBtn');
        const modal = document.getElementById('guideModal');
        const guideContent = document.getElementById('guideContent');
        let guideLoaded = false;
    
        async function openGuide() {
            modal.classList.add('visible');
            if (!guideLoaded) {
                guideContent.innerHTML = "<p>Chargement du guide...</p>";
                try {
                    const url = 'https://raw.githubusercontent.com/polog8/ICT/main/README.md';
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`Erreur réseau : ${response.statusText}`);
                    }
                    const markdownContent = await response.text();
                    guideContent.innerHTML = marked.parse(markdownContent);
                    guideLoaded = true;
                } catch (error) {
                    console.error("Erreur lors du chargement du guide:", error);
                    guideContent.innerHTML = `<p style="color:var(--danger);">Impossible de charger le guide. Veuillez vérifier la console pour plus de détails ou <a href="https://github.com/polog8/ICT/blob/main/README.md" target="_blank" rel="noopener noreferrer">consultez-le directement sur GitHub</a>.</p>`;
                }
            }
        }
    
        function closeGuide() {
            modal.classList.remove('visible');
        }
    
        guideBtn.addEventListener('click', openGuide);
        modal.addEventListener('click', (event) => {
            if (event.target === modal) {
                closeGuide();
            }
        });
    
        // --- Variables globales pour le canvas et l'état de l'application ---
        let canvas = document.getElementById("imageCanvas"),
            ctx = canvas.getContext("2d"),
            image = new Image(),
            areas = [];
        let startX, startY, currentRect = null,
            drawing = false,
            scaleFactor = 1.5,
            hoveredAreaIndex = -1,
            selectedAreaIndex = -1,
            isDraggingArea = false,
            dragOffset = {
                x: 0,
                y: 0
            },
            isResizingArea = false,
            resizeCorner = null;
        const handleSize = 6;
        const handleTolerance = 4;
        let snapEnabled = false,
            snapGrid = 5;
    
        let currentShape = 'rect'; // Forme active par défaut
        let isDrawingPoly = false;
        let currentPolyPoints = [];
    
        // --- Initialisation des boutons de l'interface ---
        const shapeButtons = {
            rect: document.getElementById('shape-rect'),
            circle: document.getElementById('shape-circle'),
            poly: document.getElementById('shape-poly')
        };
    
        function setActiveShape(shape) {
            // Annule tout dessin en cours
            isDrawingPoly = false;
            currentPolyPoints = [];
            drawing = false;
            currentRect = null;
            
            currentShape = shape;
            for (const key in shapeButtons) {
                shapeButtons[key].classList.remove('active');
            }
            shapeButtons[shape].classList.add('active');
            
            // Active le mode de dessin de polygone si l'outil est sélectionné
            if (shape === 'poly' && image.src) {
                isDrawingPoly = true;
            }
            
            const instructions = document.querySelector('.section-description');
            if (shape === 'poly') {
                instructions.innerHTML = `Mode Polygone : Cliquez pour ajouter des points. Appuyez sur <strong>Entrée</strong> pour terminer.`;
            } else {
                instructions.innerHTML = `Pour créer une zone : cliquez et faites glisser sur l'image. Pour sélectionner une zone existante : cliquez dessus.`;
            }
            redrawCanvas();
        }
    
        shapeButtons.rect.addEventListener('click', () => setActiveShape('rect'));
        shapeButtons.circle.addEventListener('click', () => setActiveShape('circle'));
        shapeButtons.poly.addEventListener('click', () => {
            setActiveShape('poly');
            if(image.src) {
                alert("Mode Polygone :\n- Cliquez pour ajouter un point.\n- Appuyez sur 'Entrée' pour terminer la forme.");
            }
        });
    
        // --- Fonctions utilitaires (Convertisseur de lien, Copier/Coller) ---
        function convertLink() {
            let input = document.getElementById("inputLink").value.trim();
            // Regex pour l'URL originale
            let regex = /https:\/\/drive\.google\.com\/file\/d\/([^\/]+)\/view(?:\?[^\/]+)?/;
            let match = input.match(regex);

            if (match && match[1]) {
                let fileId = match[1];
                // Utilisation de l'ancien format avec lh3.googleusercontent.com
                let newLink = `https://lh3.googleusercontent.com/d/${fileId}`;
                let embedCode = `<img src="${newLink}" usemap="#image-map" style="max-width:100%; height:auto;">`;

                // Modifie l'affichage du premier résultat
                let out = document.getElementById("output");
                out.style.display = "flex";
                out.innerHTML = `<p>Lien brut</p>`;

                let btnLink = document.createElement("button");
                btnLink.className = "btn-secondary";
                btnLink.textContent = 'Copier le lien';
                btnLink.addEventListener("click", () => {
                    copyToClipboard(newLink, btnLink);
                });
                // S'assure que le bouton n'est pas ajouté plusieurs fois
                if (out.children.length > 1) {
                    out.removeChild(out.lastChild);
                }
                out.appendChild(btnLink);

                // Met à jour l'URL pour l'outil de mapping
                document.getElementById("imageURL").value = newLink;

                // Modifie l'affichage du second résultat
                let embedOut = document.getElementById("embedOutput");
                embedOut.style.display = "flex";
                embedOut.innerHTML = "<p>Code d'intégration HTML</p>";

                let btnEmbed = document.createElement("button");
                btnEmbed.className = "btn-secondary";
                btnEmbed.textContent = 'Copier le code';
                btnEmbed.addEventListener("click", () => {
                    copyToClipboard(embedCode, btnEmbed);
                });
                // S'assure que le bouton n'est pas ajouté plusieurs fois
                if (embedOut.children.length > 1) {
                    embedOut.removeChild(embedOut.lastChild);
                }
                embedOut.appendChild(btnEmbed);

            } else {
                document.getElementById("output").style.display = "flex";
                document.getElementById("output").innerHTML = "<p>Format de lien Google Drive invalide.</p>";
                document.getElementById("embedOutput").style.display = "none";
            }
        }
    
        function copyToClipboard(text, button) {
            navigator.clipboard.writeText(text).then(() => {
                if (button) {
                    const originalText = button.textContent;
                    button.textContent = 'Copié !';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 2000);
                }
            }).catch(err => console.error("Erreur lors de la copie :", err));
        }
    
        function copyHtmlCode() {
            let htmlOutput = document.getElementById("htmlOutput").value;
            let copyButton = document.getElementById("copyHtmlButton");
            copyToClipboard(htmlOutput, copyButton);
        }
    
        // --- Fonctions principales de l'outil de mapping ---
        function loadImage() {
            let url = document.getElementById("imageURL").value.trim();
            if (!url) {
                alert("Veuillez entrer une URL d'image valide.");
                return;
            }
    
            image.src = url;
            image.onload = () => {
                canvas.width = image.width * scaleFactor;
                canvas.height = image.height * scaleFactor;
                resetZones();
            };
    
            image.onerror = () => {
                alert("Impossible de charger l'image. Vérifiez l'URL et que le partage de lien est bien activé sur Google Drive.");
            };
        }
    
        function updateAreaBoundingBox(area) {
            if (!area) return;
    
            switch (area.shape) {
                case 'rect':
                    break;
                case 'circle':
                    area.x = area.cx - area.radius;
                    area.y = area.cy - area.radius;
                    area.width = area.radius * 2;
                    area.height = area.radius * 2;
                    break;
                case 'poly':
                    let minX = Infinity,
                        minY = Infinity,
                        maxX = -Infinity,
                        maxY = -Infinity;
                    area.points.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x);
                        maxY = Math.max(maxY, p.y);
                    });
                    area.x = minX;
                    area.y = minY;
                    area.width = maxX - minX;
                    area.height = maxY - minY;
                    break;
            }
        }
    
        function moveArea(area, dx, dy) {
            if (!area) return;
            const deltaX = dx / scaleFactor;
            const deltaY = dy / scaleFactor;
    
            switch (area.shape) {
                case 'circle':
                    area.cx += deltaX;
                    area.cy += deltaY;
                    break;
                case 'poly':
                    area.points.forEach(p => {
                        p.x += deltaX;
                        p.y += deltaY;
                    });
                    break;
                case 'rect':
                default:
                    area.x += deltaX;
                    area.y += deltaY;
                    break;
            }
            updateAreaBoundingBox(area);
        }
    
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (image.src) {
                ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
            }
    
            areas.forEach((area, index) => {
                ctx.save();
    
                if (index === selectedAreaIndex) {
                    ctx.fillStyle = "rgba(59, 130, 246, 0.3)";
                    ctx.strokeStyle = "rgba(59, 130, 246, 1)";
                    ctx.lineWidth = 2;
                } else if (index === hoveredAreaIndex) {
                    ctx.fillStyle = "rgba(59, 130, 246, 0.2)";
                    ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
                    ctx.lineWidth = 1.5;
                } else {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
                    ctx.strokeStyle = area.color || "#ff0000";
                    ctx.lineWidth = 2;
                }
    
                ctx.beginPath();
                switch (area.shape) {
                    case 'circle':
                        ctx.arc(area.cx * scaleFactor, area.cy * scaleFactor, area.radius * scaleFactor, 0, Math.PI * 2);
                        break;
                    case 'poly':
                        area.points.forEach((p, i) => {
                            const x = p.x * scaleFactor;
                            const y = p.y * scaleFactor;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        });
                        ctx.closePath();
                        break;
                    case 'rect':
                    default:
                        ctx.rect(area.x * scaleFactor, area.y * scaleFactor, area.width * scaleFactor, area.height * scaleFactor);
                        break;
                }
                ctx.fill();
                ctx.stroke();
                ctx.restore();
    
                if (index === selectedAreaIndex) {
                    const handles = getHandlesForArea(area);
                    drawHandles(handles);
                }
            });
    
            if (isDrawingPoly && currentPolyPoints.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
                ctx.lineWidth = 2;
                currentPolyPoints.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(p.x, p.y);
                    else ctx.lineTo(p.x, p.y);
                });
                ctx.stroke();
            }
    
            if (currentRect) {
                ctx.fillStyle = "rgba(59, 130, 246, 0.3)";
                ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
                ctx.lineWidth = 2;
                if (currentShape === 'rect') {
                    ctx.fillRect(currentRect.x, currentRect.y, currentRect.w, currentRect.h);
                    ctx.strokeRect(currentRect.x, currentRect.y, currentRect.w, currentRect.h);
                } else if (currentShape === 'circle') {
                    const radius = Math.sqrt(Math.pow(currentRect.w, 2) + Math.pow(currentRect.h, 2));
                    ctx.beginPath();
                    ctx.arc(currentRect.x, currentRect.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }
    
        // REMPLACER les fonctions drawHandles et detectHandle par celles-ci

        /**
         * Dessine un tableau de poignées sur le canvas.
         * @param {Array} handles - Un tableau d'objets poignée.
         */
        function drawHandles(handles) {
            handles.forEach(handle => {
                ctx.save();
                ctx.fillStyle = "white";
                ctx.strokeStyle = "rgba(59, 130, 246, 0.8)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(handle.x * scaleFactor, handle.y * scaleFactor, handleSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            });
        }

        /**
         * Retourne un tableau d'objets représentant les poignées de modification pour une zone donnée.
         * @param {Object} area - La zone pour laquelle obtenir les poignées.
         * @returns {Array} - Un tableau d'objets poignée.
         */
        function getHandlesForArea(area) {
            if (!area) return [];
            const handles = [];

            switch (area.shape) {
                case 'rect':
                    const x = area.x, y = area.y, w = area.width, h = area.height;
                    // Les 8 poignées du rectangle
                    handles.push({ x: x,       y: y,       type: 'rect-resize', corner: 'tl' });
                    handles.push({ x: x + w/2, y: y,       type: 'rect-resize', corner: 'tc' });
                    handles.push({ x: x + w,   y: y,       type: 'rect-resize', corner: 'tr' });
                    handles.push({ x: x,       y: y + h/2, type: 'rect-resize', corner: 'ml' });
                    handles.push({ x: x + w,   y: y + h/2, type: 'rect-resize', corner: 'mr' });
                    handles.push({ x: x,       y: y + h,   type: 'rect-resize', corner: 'bl' });
                    handles.push({ x: x + w/2, y: y + h,   type: 'rect-resize', corner: 'bc' });
                    handles.push({ x: x + w,   y: y + h,   type: 'rect-resize', corner: 'br' });
                    break;
                case 'circle':
                    // Poignée pour le rayon du cercle (1 poignée)
                    handles.push({ x: area.cx + area.radius, y: area.cy, type: 'circle-resize' });
                    break;
                case 'poly':
                    // Poignées pour chaque sommet du polygone
                    area.points.forEach((point, index) => {
                        handles.push({ x: point.x, y: point.y, type: 'poly-move-point', index: index });
                    });
                    break;
            }
            return handles;
        }
    
        function getAreaAt(x, y) {
            for (let i = areas.length - 1; i >= 0; i--) {
                let area = areas[i];
                let isInside = false;
    
                switch (area.shape) {
                    case 'circle':
                        const dist = Math.sqrt(Math.pow((x / scaleFactor) - area.cx, 2) + Math.pow((y / scaleFactor) - area.cy, 2));
                        if (dist <= area.radius) isInside = true;
                        break;
                    case 'poly':
                        let pointX = x / scaleFactor, pointY = y / scaleFactor;
                        let polyPoints = area.points;
                        let j = polyPoints.length - 1;
                        for (let k = 0; k < polyPoints.length; k++) {
                            if ((polyPoints[k].y > pointY) !== (polyPoints[j].y > pointY) &&
                                (pointX < (polyPoints[j].x - polyPoints[k].x) * (pointY - polyPoints[k].y) / (polyPoints[j].y - polyPoints[k].y) + polyPoints[k].x)) {
                                isInside = !isInside;
                            }
                            j = k;
                        }
                        break;
                    case 'rect':
                    default:
                        if (x >= area.x * scaleFactor && x <= (area.x + area.width) * scaleFactor &&
                            y >= area.y * scaleFactor && y <= (area.y + area.height) * scaleFactor) {
                            isInside = true;
                        }
                        break;
                }
                if (isInside) return i;
            }
            return -1;
        }
    
        // REMPLACEZ votre fonction updateAreasTable actuelle par celle-ci

        function updateAreasTable() {
            let tbody = document.querySelector("#areasTable tbody");
            tbody.innerHTML = "";
            areas.forEach((area, index) => {
                let row = document.createElement("tr");
                let coordsText = '';
                switch (area.shape) {
                    case 'circle':
                        coordsText = `cx:${Math.round(area.cx)}, cy:${Math.round(area.cy)}, r:${Math.round(area.radius)}`;
                        break;
                    case 'poly':
                        coordsText = `${area.points.length} points`;
                        break;
                    case 'rect':
                    default:
                        coordsText = `x:${Math.round(area.x)}, y:${Math.round(area.y)}, w:${Math.round(area.width)}, h:${Math.round(area.height)}`;
                        break;
                }

                // Le bloc <td> pour l'ordre est maintenant inclus ici
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>
                        <button onclick="moveAreaOrder(${index}, -1)" title="Monter" style="padding:4px; border:none; background:transparent; cursor:pointer; color: black;" ${index === 0 ? 'disabled' : ''}>▲</button>
                        <button onclick="moveAreaOrder(${index}, 1)" title="Descendre" style="padding:4px; border:none; background:transparent; cursor:pointer; color: black;" ${index === areas.length - 1 ? 'disabled' : ''}>▼</button>
                    </td>
                    <td>${area.shape}</td>
                    <td>${coordsText}</td>
                    <td>${area.title || ''}</td>
                    <td>${area.link || ''}</td>
                    <td>${area.target}</td>
                    <td><span style="display:inline-block;width:20px;height:20px;background:${area.color};border-radius:50%; border: 1px solid var(--gray-light);"></span></td>
                    <td>
                        <button class="btn-edit btn-outline" onclick="editArea(${index})">Modifier</button>
                        <button class="btn-delete btn-danger" onclick="deleteArea(${index})">Supprimer</button>
                    </td>`;
                tbody.appendChild(row);
            });
        }
    
        function moveAreaOrder(index, direction) {
            const newIndex = index + direction;

            // Vérifie si le déplacement est possible
            if (newIndex < 0 || newIndex >= areas.length) {
                return;
            }

            // Intervertit les éléments dans le tableau
            [areas[index], areas[newIndex]] = [areas[newIndex], areas[index]];

            // Met à jour l'index de la zone sélectionnée si elle a été déplacée
            if (selectedAreaIndex === index) {
                selectedAreaIndex = newIndex;
            } else if (selectedAreaIndex === newIndex) {
                selectedAreaIndex = index;
            }

            // Rafraîchit l'interface pour refléter le nouvel ordre
            updateAreasTable();
            updateHTML();
            redrawCanvas();
        }
    
        function editArea(index) {
            selectedAreaIndex = index;
            showEditor(areas[index]);
            redrawCanvas();
        }
    
        function showEditor(area) {
            document.getElementById("zoneEditor").style.display = "block";
            document.getElementById("editTitle").value = area.title;
            document.getElementById("editLink").value = area.link;
            document.getElementById("editTarget").value = area.target;
            document.getElementById("editColor").value = area.color || "#ff0000";
        }
    
        function cancelEdit() {
            selectedAreaIndex = -1;
            document.getElementById("zoneEditor").style.display = "none";
            redrawCanvas();
        }
    
        function updateZone() {
            if (selectedAreaIndex === -1) return;
            areas[selectedAreaIndex].title = document.getElementById("editTitle").value;
            areas[selectedAreaIndex].link = document.getElementById("editLink").value;
            areas[selectedAreaIndex].target = document.getElementById("editTarget").value;
            areas[selectedAreaIndex].color = document.getElementById("editColor").value;
            
            updateAreasTable();
            updateHTML();
            
            // On ferme la fenêtre d'édition et on désélectionne la zone
            cancelEdit(); 
        }
    
        function deleteArea(index) {
            if (!confirm(`Voulez-vous vraiment supprimer la zone #${index + 1} ?`)) return;
            areas.splice(index, 1);
            if (selectedAreaIndex === index) {
                selectedAreaIndex = -1;
                cancelEdit();
            } else if (selectedAreaIndex > index) {
                selectedAreaIndex--;
            }
            updateAreasTable();
            updateHTML();
            redrawCanvas();
        }
    
        // REMPLACER toute la fonction updateHTML par celle-ci
        function updateHTML() {
            let imageSrc = document.getElementById("imageURL").value;
            let htmlCode = `<style>
            #image-container { position: relative; display: inline-block; max-width: 100%; }
            #image-container img { width: 100%; height: auto; display: block; }
            #hover-effect { position: absolute; background: rgba(59, 130, 246, 0.4); border: 1px solid rgba(255, 255, 255, 0.7); transition: all 0.2s ease-in-out; pointer-events: none; display: none; }
            #tooltip { position: absolute; background: rgba(0, 0, 0, 0.85); color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px; white-space: nowrap; display: none; z-index: 1000; pointer-events: none; }
        </style>
        <div id="image-container">
            <img src="${imageSrc}" usemap="#image-map">
            <div id="hover-effect"></div>
            <div id="tooltip"></div>
        </div>
        <map name="image-map">`;

            areas.forEach(area => {
                let coords = '';
                switch(area.shape) {
                    case 'circle':
                        coords = `${Math.round(area.cx)},${Math.round(area.cy)},${Math.round(area.radius)}`;
                        break;
                    case 'poly':
                        coords = area.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(',');
                        break;
                    case 'rect':
                    default:
                        let x1 = Math.round(area.x), y1 = Math.round(area.y);
                        let x2 = Math.round(area.x + area.width), y2 = Math.round(area.y + area.height);
                        coords = `${x1},${y1},${x2},${y2}`;
                        break;
                }
                
                // CORRECTION : Remplacer les guillemets par l'entité HTML &quot;
                let formattedTitle = (area.title || "").replace(/"/g, "&quot;").replace(/\n/g, "<br>");
                htmlCode += `\n    <area shape="${area.shape}" coords="${coords}" href="${area.link || '#'}" target="${area.target}" data-tooltip="${formattedTitle}" class="hover-area">`;
            });

            // CORRECTION : Échapper correctement les backticks ` dans le script généré
            htmlCode += `
        </map>
        <script src="https://cdn.jsdelivr.net/npm/image-map-resizer@1.0.10/js/imageMapResizer.min.js"><\/script>
        <script>
            imageMapResize();
            const imageContainer = document.getElementById("image-container");
            const hoverEffect = document.getElementById("hover-effect");
            const tooltip = document.getElementById("tooltip");
            const hoverAreas = document.querySelectorAll(".hover-area");
            
            hoverAreas.forEach(area => {
                area.addEventListener("mouseenter", (event) => {
                    const shape = event.target.shape;
                    const coords = event.target.coords.split(",").map(Number);
                    
                    hoverEffect.style.borderRadius = '0';
                    hoverEffect.style.clipPath = 'none';
                    hoverEffect.style.display = "block";

                    if (shape === 'rect') {
                        hoverEffect.style.left = coords[0] + "px";
                        hoverEffect.style.top = coords[1] + "px";
                        hoverEffect.style.width = (coords[2] - coords[0]) + "px";
                        hoverEffect.style.height = (coords[3] - coords[1]) + "px";
                    } 
                    else if (shape === 'circle') {
                        const [cx, cy, radius] = coords;
                        hoverEffect.style.left = (cx - radius) + 'px';
                        hoverEffect.style.top = (cy - radius) + 'px';
                        hoverEffect.style.width = (radius * 2) + 'px';
                        hoverEffect.style.height = (radius * 2) + 'px';
                        hoverEffect.style.borderRadius = '50%';
                    } 
                    else if (shape === 'poly') {
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        for (let i = 0; i < coords.length; i += 2) {
                            minX = Math.min(minX, coords[i]);
                            maxX = Math.max(maxX, coords[i]);
                            minY = Math.min(minY, coords[i + 1]);
                            maxY = Math.max(maxY, coords[i + 1]);
                        }
                        hoverEffect.style.left = minX + 'px';
                        hoverEffect.style.top = minY + 'px';
                        hoverEffect.style.width = (maxX - minX) + 'px';
                        hoverEffect.style.height = (maxY - minY) + 'px';
                        const clipPathPoints = [];
                        for (let i = 0; i < coords.length; i += 2) {
                            clipPathPoints.push(\`\${coords[i] - minX}px \${coords[i + 1] - minY}px\`);
                        }
                        hoverEffect.style.clipPath = \`polygon(\${clipPathPoints.join(', ')})\`;
                    }

                    let text = event.target.getAttribute("data-tooltip");
                    if (text) {
                        tooltip.innerHTML = text;
                        tooltip.style.display = "block";
                    }
                });
                area.addEventListener("mousemove", (event) => {
                    if (tooltip.style.display !== 'block') return;
                    const containerRect = imageContainer.getBoundingClientRect();
                    const mouseX = event.clientX - containerRect.left;
                    const mouseY = event.clientY - containerRect.top;
                    const tooltipWidth = tooltip.offsetWidth;
                    const tooltipHeight = tooltip.offsetHeight;
                    const maxX = containerRect.width - tooltipWidth;
                    const maxY = containerRect.height - tooltipHeight;
                    tooltip.style.left = Math.max(0, Math.min(mouseX + 15, maxX)) + "px";
                    tooltip.style.top = Math.max(0, Math.min(mouseY + 15, maxY)) + "px";
                });
                area.addEventListener("mouseleave", () => {
                    hoverEffect.style.display = "none";
                    tooltip.style.display = "none";
                });
            });
        <\/script>`;
            document.getElementById("htmlOutput").value = htmlCode;
        }
    
        function resetZones() {
            areas = [];
            selectedAreaIndex = -1;
            cancelEdit();
            updateAreasTable();
            updateHTML();
            redrawCanvas();
        }
    
        // --- Fonctions de sauvegarde/chargement des configurations ---
        function updateConfigList() {
            let savedConfigs = JSON.parse(localStorage.getItem("imageMapperConfigs")) || {};
            let configsList = document.getElementById("configsList");
            configsList.innerHTML = "";
    
            let configNames = Object.keys(savedConfigs).sort();
            configNames.forEach(name => {
                let listItem = document.createElement("li");
                listItem.className = "config-item";
    
                let link = document.createElement("a");
                link.href = "#";
                link.textContent = name;
                link.onclick = (e) => {
                    e.preventDefault();
                    loadZonesByName(name);
                };
    
                let dropdown = document.createElement("div");
                dropdown.className = "dropdown";
                dropdown.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-three-dots-vertical" viewBox="0 0 16 16">
                        <path d="M3 9.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3z"/>
                    </svg>
                    <div class="dropdown-content">
                        <a href="#" onclick="event.preventDefault(); deleteConfig('${name}')">Supprimer</a>
                    </div>
                `;
    
                listItem.appendChild(link);
                listItem.appendChild(dropdown);
                configsList.appendChild(listItem);
            });
        }
    
        function deleteConfig(name) {
            if (confirm(`Voulez-vous vraiment supprimer la configuration "${name}" ?`)) {
                let savedConfigs = JSON.parse(localStorage.getItem("imageMapperConfigs")) || {};
                delete savedConfigs[name];
                localStorage.setItem("imageMapperConfigs", JSON.stringify(savedConfigs));
                updateConfigList();
                alert(`Configuration "${name}" supprimée.`);
            }
        }
    
        function loadZonesByName(configName) {
            let savedConfigs = JSON.parse(localStorage.getItem("imageMapperConfigs")) || {};
            if (savedConfigs[configName]) {
                areas = savedConfigs[configName];
                areas.forEach(area => updateAreaBoundingBox(area)); // Assurer la compatibilité
                updateAreasTable();
                updateHTML();
                redrawCanvas();
                alert("Configuration " + configName + " chargée !");
            } else {
                alert("Configuration introuvable.");
            }
        }
    
        function saveZones() {
            let configName = prompt("Entrez un nom pour cette configuration :");
            if (configName) {
                let savedConfigs = JSON.parse(localStorage.getItem("imageMapperConfigs")) || {};
                savedConfigs[configName] = areas;
                localStorage.setItem("imageMapperConfigs", JSON.stringify(savedConfigs));
                alert("Configuration sauvegardée sous le nom : " + configName);
                updateConfigList();
            }
        }
    
        function loadZones() {
            let configName = prompt("Entrez le nom de la configuration à charger :");
            if (configName) {
                loadZonesByName(configName);
            }
        }
    
        updateConfigList();
    
        function toggleSnap() {
            snapEnabled = document.getElementById("snapToggle").checked;
        }
    
        // --- Gestionnaires d'événements du Canvas ---
        canvas.addEventListener("mousedown", event => {
            event.preventDefault();
            if (isDrawingPoly) {
                currentPolyPoints.push({ x: event.offsetX, y: event.offsetY });
                redrawCanvas();
                return;
            }
    
            const mouseX = event.offsetX;
            const mouseY = event.offsetY;
            const areaIndex = getAreaAt(mouseX, mouseY);
    
            // NOUVELLE VERSION
            if (areaIndex !== -1) { // Clic sur une zone existante
                const area = areas[areaIndex];
                selectedAreaIndex = areaIndex;
                isDraggingArea = true; // Par défaut on drague la forme
                isResizingArea = false;
                
                dragOffset.x = mouseX - area.x * scaleFactor;
                dragOffset.y = mouseY - area.y * scaleFactor;

                // Cherche si on a cliqué sur une poignée
                const handles = getHandlesForArea(area);
                for (const handle of handles) {     
                    const hx = handle.x * scaleFactor;
                    const hy = handle.y * scaleFactor;
                    const distance = Math.sqrt(Math.pow(mouseX - hx, 2) + Math.pow(mouseY - hy, 2));

                    if (distance <= handleSize + handleTolerance) {
                        isResizingArea = true;
                        isDraggingArea = false; // On ne drague pas si on redimensionne
                        resizeCorner = handle; // On stocke l'objet poignée entier
                        break; 
                    }
                }
                
                showEditor(area);
                redrawCanvas();
                return;
            }
    
            selectedAreaIndex = -1;
            cancelEdit();
            drawing = true;
            startX = mouseX;
            startY = mouseY;
            currentRect = { x: startX, y: startY, w: 0, h: 0 };
        });

        canvas.addEventListener("mousemove", event => {
            const mouseX = event.offsetX;
            const mouseY = event.offsetY;

            if (isDraggingArea && selectedAreaIndex !== -1) {
                canvas.classList.add('dragging');
                // Calcule la nouvelle position du coin supérieur gauche de la forme
                const newX = mouseX - dragOffset.x;
                const newY = mouseY - dragOffset.y;
                
                const area = areas[selectedAreaIndex];
                // Calcule le delta de mouvement par rapport à l'ancienne position
                const dx = newX - (area.x * scaleFactor);
                const dy = newY - (area.y * scaleFactor);
                
                moveArea(area, dx, dy);
                
            } else if (isResizingArea && selectedAreaIndex !== -1) {
                const area = areas[selectedAreaIndex];
                
                switch (resizeCorner.type) {
                    case 'circle-resize':
                        const newRadius = Math.sqrt(Math.pow(mouseX / scaleFactor - area.cx, 2) + Math.pow(mouseY / scaleFactor - area.cy, 2));
                        area.radius = newRadius;
                        break;
                        
                    case 'poly-move-point':
                        const pointIndex = resizeCorner.index;
                        area.points[pointIndex].x = mouseX / scaleFactor;
                        area.points[pointIndex].y = mouseY / scaleFactor;
                        break;

                    case 'rect-resize':
                            case 'rect-resize':
                                const corner = resizeCorner.corner;
                                let ax = area.x * scaleFactor, ay = area.y * scaleFactor;
                                let aw = area.width * scaleFactor, ah = area.height * scaleFactor;
                                
                                // Logique de redimensionnement pour chaque coin/côté
                                if (corner.includes('t')) {
                                    let newHeight = ah - (mouseY - ay);
                                    area.y = mouseY / scaleFactor;
                                    area.height = newHeight / scaleFactor;
                                }
                                if (corner.includes('b')) {
                                    area.height = (mouseY - ay) / scaleFactor;
                                }
                                if (corner.includes('l')) {
                                    let newWidth = aw - (mouseX - ax);
                                    area.x = mouseX / scaleFactor;
                                    area.width = newWidth / scaleFactor;
                                }
                                if (corner.includes('r')) {
                                    area.width = (mouseX - ax) / scaleFactor;
                                }
                                break;
                        break;
                }

                updateAreaBoundingBox(area);
                updateAreasTable();
                updateHTML();

            } else if (drawing) {
                currentRect.w = mouseX - startX;
                currentRect.h = mouseY - startY;
            } else {
                hoveredAreaIndex = getAreaAt(mouseX, mouseY);
                canvas.classList.toggle('draggable', hoveredAreaIndex !== -1);
            }
            
            redrawCanvas();
        });
    
        canvas.addEventListener("mouseup", () => {
            if (isDrawingPoly) return;
    
            if (drawing) {
                drawing = false;
                let newArea = null;
    
                switch (currentShape) {
                    case 'circle':
                        const radius = Math.sqrt(Math.pow(currentRect.w, 2) + Math.pow(currentRect.h, 2)) / scaleFactor;
                        if (radius > 5) {
                            newArea = { shape: 'circle', cx: startX / scaleFactor, cy: startY / scaleFactor, radius, title: "", link: "", target: "_top", color: "#ff0000" };
                        }
                        break;
                    case 'rect':
                    default:
                        let rect = { x: currentRect.x / scaleFactor, y: currentRect.y / scaleFactor, width: currentRect.w / scaleFactor, height: currentRect.h / scaleFactor };
                        if (rect.width < 0) { rect.x += rect.width; rect.width = Math.abs(rect.width); }
                        if (rect.height < 0) { rect.y += rect.height; rect.height = Math.abs(rect.height); }
                        if (rect.width > 5 && rect.height > 5) {
                            newArea = { ...rect, shape: 'rect', title: "", link: "", target: "_top", color: "#ff0000" };
                        }
                        break;
                }
    
                if (newArea) {
                    updateAreaBoundingBox(newArea);
                    areas.push(newArea);
                    selectedAreaIndex = areas.length - 1;
                    showEditor(newArea);
                    updateAreasTable();
                    updateHTML();
                }
                currentRect = null;
            }
    
            isDraggingArea = false;
            isResizingArea = false;
            canvas.classList.remove('dragging');
            redrawCanvas();
        });
    
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && isDrawingPoly && currentPolyPoints.length > 2) {
                event.preventDefault();
                isDrawingPoly = false;
                const newPoly = { shape: 'poly', points: currentPolyPoints.map(p => ({ x: p.x / scaleFactor, y: p.y / scaleFactor })), title: "", link: "", target: "_top", color: "#ff0000" };
    
                updateAreaBoundingBox(newPoly);
                areas.push(newPoly);
                selectedAreaIndex = areas.length - 1;
                showEditor(newPoly);
    
                currentPolyPoints = [];
                updateAreasTable();
                updateHTML();
                redrawCanvas();
            }
    
            if (event.key === 'Escape') {
                if (modal.classList.contains('visible')) {
                    closeGuide();
                } else if (isDrawingPoly) {
                    isDrawingPoly = false;
                    currentPolyPoints = [];
                    redrawCanvas();
                } else if(selectedAreaIndex !== -1) {
                    cancelEdit();
                }
            }
        });
    </script>
</body>
</html>
